\ProvidesFile{lect-04.tex}[Лекция 4]

\section{Лекция 4}

\begin{theorem}[Клини о неподвижной точке]
    Пусть $U$ --- главная универсальная вычислимая функция, $f: \N \to \N$ --- произвольная вычислимая тотальная функция.
    Тогда существует $n \in \N$ такое, что $U_{f\left(n\right)} = U_{n}$, то есть
    $$
        \exists n \quad \forall x \quad U\left(n, x\right) \simeq U\left(f\left(n\right), x\right).
    $$
\end{theorem}

На прошлой лекции мы доказали теорему Клини.
С одной стороны, вы можете возразить, что же такого потрясающего в этом результате, бред же какой-то.
На самом деле, если мы вспомним нашу содержательную интерпертацию символов, которые здесь есть, то оказывается, что это все не является бредом.
$U$ --- функция, которую вычисляет некоторый универсальный алгоритм $\UU$, то есть интерпретатор какого-то языка программирования.
Первые аргументы функции $U$, то есть $n$ и $f(n)$ --- это какие-то программы, а значение функции $U\left(n, x\right)$ --- это то, что вычисляет программа $n$ на входе $x$.
Тогда $f$ можно рассматривать как некоторое алгоритмическое преобразование программ.
И оказывается, что в главном языке программирования для любого алгоритмического преобразования программ найдется такая программа, чей смысл не меняется.
Этот же факт означает, что ни одно алгоритмическое преобразование не может поменять смысл всех программ.

\subsection{Теорема о рекурсии}

Следствием теоремы Клини является факт, который мы будем называть теоремой о рекурсии.
\begin{corollary}[Теорема о рекурсии]
    Пусть $U$ --- главная универсальная вычислимая функция, и $V: \N^{2} \pto \N$ --- произвольная вычислимая функция\footnote{мы можем рассматривать ее как какой-то язык программирования, где первый аргумент --- программы, а второй аргумент --- их входной набор данных} двух аргументов.
    Тогда $\exists n \in \N$ такое, что
    $$
        U_{n} = V_{n}.
    $$
    Последнее равенство равносильно
    $$
        \exists n \quad \forall x \quad U\left(n, x\right) \simeq V\left(n, x\right).
    $$
\end{corollary}
То есть, у нас существует такая программа, которая имеет на главном языке такой же смысл, что и на языке $V$.
Вы спросите, а как вообще так?
А вдруг один язык таков, что ни одна корректная программа не является корректной для другого?
Тогда это утверждение не является верным, однако мы договорились, что все натуральные числа являются корректными программами, а в таком случае все хорошо.

\begin{proof}
    И так, определение главной универсальной вычислимой функции гарантирует нам существование какой-то вычислимой тотальной функции.
    В тоже время, теорема Клини принимает какую-то вычислимую тотальную функцию на вход.
    Применим эти два факта и все получится.

    Формально, так как $U$ --- главная, то существует вычислимая тотальная $S$ такая, что $\forall k$ $U_{S(k)} = V_{k}$.
    Но, по теореме Клини, существует неподвижная точка $n$ для $S$, то есть $\exists n: U_{S(n)} = U_{n}$.
    Тогда
    $$
        \exists n: \quad U_{n} = U_{S(n)} = V_{n},
    $$
    что и требовалось показать.
\end{proof}

Причем тут вообще рекурсия?
А при том, что функция $V$ может сама по себе вызывать функцию $U$.

\begin{example}
    Существует такая программа $n$, которая на любом входе выводит саму себя.
    То есть,
    $$
        \exists n: \quad \forall x \quad U(n, x) = n.
    $$
\end{example}
\begin{proof}
    Рассмотрим $V\left(k, x\right) = k$, она вычислима.
    Тогда, по теореме о рекурсии, $\exists n$ такое, что $\forall x$ $U(n, x) \simeq V(n, x) \implies \exists n$ $\forall x$ $U(n, x) = n$.
\end{proof}

\begin{example}
    Существует такая программа $n$, которая на любом входе $x$ возвращает то же, что и программа $x$ на входе $n$.
    То есть, $\exists n:$ $\forall x$ $U(n, x) \simeq U(x, n)$. 
\end{example}

Доказательство последнего примера полностью аналогично примеру 1.
Таких примеров можно привести бесконечное количество, поэтому надо просто усвоить один важный факт: {\it в главных языках программирования программа может иметь доступ к своему коду}.

Как с этим всем связана рекурсия?
Приходилось ли вам писать рекурсивные алгоритмы на каком-нибудь языке программирования (например, C).
Наверное, приходилось.
А как устроен рекурсивный алгоритм?
На каком-то этапе вычисления функции $f$, она использует свой собственный код, то есть вызывает функцию $f$.

С другой стороны, на этот факт можно посмотреть как на уравнение.
\begin{statement}
    $\exists$ вычислимая функция $f$ такая, что
    $$
        \begin{cases}
            f(0) = 1, & x = 0, \\
            f(x) = x \cdot f(x - 1), & x > 0. 
        \end{cases}
    $$
\end{statement}
Заметим, что выражение выше является {\it системой из уравнений} на функцию $f$.
Поэтому можно задать два вопроса: 
\begin{enumerate}
    \item существует ли такая $f$?
    \item единственна ли такая $f$?
\end{enumerate}
Оказывается, теорема Клини легко нам показывает, что такая функция существует.
То есть, по некоторым условиям на функцию $f$ нам гарантировано существование алгоритма, который эту функцию вычисляет.

\begin{proof}
    Рассмотрим 
    $$
        V\left(k, x\right) \simeq \begin{cases}
            1, & x = 0, \\
            U\left(k, x - 1\right) \cdot x, & x > 0.
        \end{cases}
    $$
    По теореме о рекурсии, $\exists n$ такое, что $\forall x$ $U(n, x) \simeq V(n, x)$, то есть
    $$
        \exists n \quad \forall x \quad U(n, x) \simeq \begin{cases}
            1, & x = 0, \\
            U(n, x - 1) \cdot x, & x > 0.
        \end{cases}
    $$
    Нам хочется, чтобы $f = U_{n}$, однако в формулировке теоремы о рекурсии нам не гарантируется, что $U_{n}$ всюду определено, в то время как $f$ должна быть всюду определена.
    Заметим, что в нуле функция $U(n, 0)$ определена, а в остальных точках ее определенность можно доказать индукцией по $x$.
    Получается, что $U_{n}$ тотальна.
    Таким образом, мы получили функцию с желаемыми свойствами $(f = U_{n})$.
\end{proof}

В чем преимущество такого подхода?
Мы описали наши пожелания относительно какой-то функции $f$, а теорема о рекурсии гарантирует нам существование алгоритма, вычисляющего $f$.

\begin{statement}
    Существует вычислимая функция $f$ такая, что $\forall x$ $f(x) \simeq 1 + f(x + 1)$.
\end{statement}

Странная функция, она в точке $x$ на единицу больше, чем в точке $x + 1$.
Что можно сказать про такую функцию?
Она монотонно убывает, потому что $f(x)$ на единицу больше, чем $f(x + 1)$.
Какое же значение у нее в нуле?
Да никакого, ведь функция из натуральных чисел в натуральные.
Может ли такая функция быть определена в каком-то натуральном числе?
Нет, потому что иначе она бы представляла собой бесконечно убывающую последовательность натуральных чисел, которой существовать не может.
Но вместе с тем, такая вычислимая функция подходит, и это очень просто понять:

\begin{proof}
    Рассмотрим вычислимую функцию $V\left(k, x\right) \simeq U(k, x + 1) + 1$.
    Правая часть вычислима, а по теореме о рекурсии существует $n$ такое, что для любого $x$ $U(n, x) \simeq V(n, x) \simeq U(n, x + 1)  + 1 \implies f = U_{n}$.
\end{proof}

То есть, такая функция все же существует.
Но что же это за функция?
Ясно, что такая функция $f = \zeta$ --- нигде не определенная функция.
Поэтому, любое уравнение вида $U(n, x) \simeq V(n, x)$ с вычислимой правой частью имеет программу $n_{0}$ --- свое решение.
Но никто не гарантирует, чтобы это решение было номером всюду определенной функции, и так далее.
То есть, понятие рекурсия в этой всей теории используется в самом широком смысле: рекурсивная функция не обязана останавливаться.
Она может нам дать нигде не определенную функцию, ведь, если передать такую функцию какому-нибудь компилятору вроде компилятора языка Си, то произойдет stack overflow ввиду конечности памяти в реальном мире.
В нашей модели памяти бесконечно много, поэтому наша программа бы просто зациклилась, как, например, зацикливается программа, вычисляющая функцию $\zeta$.

\subsection{Теорема о совместной рекурсии}

Оказывается, с помощью конструкций вида
$$
    U(n, x) \simeq V(n, x)
$$
с вычислимой правой частью, можно решать не только уравнения на вычислимую функцию, но и системы уравнений.

\begin{example}
    Существуют такие программы $a$ и $b$, что для любого $x$
    \begin{align}
        U(a, x) &= b, \\
        U(b, x) &= a + 1.
    \end{align}
\end{example}

Такая концепция в программировании называется {\it совместной рекурсией}: когда мы определяем одну функцию через другую, а эту функцию через первую.
Совместная рекурсия встречается и в реальной жизни, например можно определить функции для проверки числа на четность:
\begin{align}
    even(0) &= 1, \\
    even(n + 1) &= odd(n), \\
    odd(0) &= 0, \\
    odd(n + 1) &= even(n).
\end{align}

\begin{theorem}[о совместной рекурсии]
    Пусть $U$ --- главная универсальная вычислимая функция, а $V_{1}$, $V_{2}$ --- произвольные вычислимые функции с нужным числом аргументов.
    Тогда $\exists a, b$ такие, что $\forall x$
    $$
        \begin{cases}
            U(a, x) \simeq V_{1}\left(a, b, x\right), \\
            U(b, x) \simeq V_{2}\left(a, b, x\right).
        \end{cases}
    $$
\end{theorem}

Мы можем решить систему уравнений: существуют два таких алгоритма, которые используют код друг-друга.
Все такие переходы от одномерного случая к двумерному делаются с помощью кодирования пар.
С другой стороны, у нас на семинаре было доказано следующее утверждение:

\begin{statement}
    Если $U$ --- главная универсальная вычислимая функция, то существует такая вычислимая тотальная функция $c$, что
    $$
        \forall p, q \quad U_{c\left(p, q\right)} = U_{p} \circ U_{q}.
    $$
    Или, если записать это в кванторах,
    $$
        \forall x \quad U\left(c(p, q), x\right) \simeq  U(p, U(q, x)).
    $$
\end{statement}

Содержательно, идея этого утверждения следующая: имея текст программы $p$ и текст программы $q$, мы можем автоматически сгенерировать текст программы, которая вычисляет $p \circ q$.
Для Си, например, это вообще тривиальное утверждение: надо просто вызвать одну функцию из другой.
Но это имеет место и в абстрактном случае.
Само доказательство этого утверждения сильно зависит от наличия так называемого кодирования пар.
Напомню, что это такое.
\begin{definition}
    Пусть у нас существует вычислимая тотальная биекция $\left\langle \cdot, \cdot \right\rangle:  \N^{2} \to \N$.
    Тогда $\left\langle \cdot, \cdot \right\rangle$ называется {\it кодированием пары}.
\end{definition}

Таких биекций много, кроме того, для такой биекции существуют вычислимые тотальные функции-проекторы $\pi_{1}$ и $\pi_{2}$ такие, что
\begin{align}
    \pi_{1}\left(\left\langle n, m \right\rangle\right) &= n, \\
    \pi_{2}\left(\left\langle n, m \right\rangle\right) &= m.
\end{align}

Если $\pi_{1}$ и $\pi_{2}$ --- вычислимые тотальные функции, то, поскольку $U$ является у. в. ф., то у них есть какие-то индексы\footnote{программы, которые их считают} $p_{1}, p_{2} \in \N$ такие, что
$$
    \pi_{1} = U_{p_{1}} \qquad \pi_{2} = U_{p_{2}}.
$$
Рассмотрим теперь функцию $V\left(k, x\right) \simeq \left\langle V_{1}\left(c(p_{1}, k), c\left(p_{2}, k\right), x\right), V_{2}\left(c(p_{1}, k), c\left(p_{2}, k\right), x\right)\right\rangle$.
Такая функция $V$ вычислима, потому что представляет собой композицию вычислимых функций.
Почему она такая?
Потому что нам так захотелось.
По теореме о рекурсии, $\exists n \in \N$ такое, что $\forall x \in \N$
$$
    U(n, x) \simeq V(n, x) \simeq \left\langle V_{1}\left(c(p_{1}, n), c\left(p_{2}, n\right), x\right), V_{2}\left(c(p_{1}, n), c\left(p_{2}, n\right), x\right)\right\rangle.
$$
Положим $a = c(p_{1}, n)$, $b = c(p_{2}, n)$, тогда
$$
    U\left(a, x\right) \simeq U\left(c\left(p_{1}, n\right), x\right) \simeq U\left(p_{1}, U\left(n, x\right)\right) \simeq \pi_{1}\left(U\left(n, x\right)\right) \simeq V_{1}\left(c\left(p_{1}, n\right), c\left(p_{2}, n\right), x\right) \simeq V_{1}\left(a, b, x\right).
$$
% Кажется, что весь текст выше --- это доказательство утверждения, про которое Дашков заявил, что не будет его доказывать

Кроме кодирования пар, можно использовать кодирование троек, и, с помощью такого кодирования, доказать это утверждение для трех программ.
Аналогично можно сделать для любого конечного числа программ.

Итак, теорема Клини позволяет решать системы уравнений на вычислимые функции.

\subsection{Теорема Райса-Успенского}

Здесь и далее $U$ --- главная универсальная вычислимая функция.
Теорему Райса-Успенского можно рассматривать как следствие теоремы Клини.
Если вы ходили на семинары, или, хотя бы, на прошлую лекцию, то вы, наверное, помните, что у нас были такие множества:
\begin{align}
    &\left\{n \in \N~|~U_{n}\text{ где-то определена}\right\}, \\
    &\left\{n \in \N~|~U_{n}\text{ монотонно возрастает на } \dom U_{n}\right\}.
\end{align}
Что это такое?
Это множество программ, которые вычисляют функцию с каким-то нетривиальным свойством.
Это вопрос, который, вообще говоря, мог бы быть интересен и на практике.
И мы с вами во всех конкретных случаях видели, что все эти множества являются неразрешимыми.
Первое множество перечислимо, второе --- нет, но никакое из них не является разрешимым.
То есть вопрос о том, можем ли мы алгоритмически узнать, обладает ли вычислимая функция $U_{n}$ каким-то конкретным свойством, решался для $U$ отрицательно.
Оказывается, что это --- общий факт, то есть нельзя алгоритмически по программе узнать, обладает ли вычисляемая ею функция какими-то свойствами\footnote{все равно, что сказать, что нетривиальные свойства функции не распознаются по номерам программ}.
Это и есть теорема Райса-Успенского.

\begin{theorem}[Райса-Успенского]
    Пусть $U$ --- главная универсальная вычислимая функция, а $\FF$ --- нетривиальное\footnote{это значит, что $\exists f \in \FF$, и $\exists g \notin \FF$} подмножество множества всех вычислимых функций $f: \N \pto \N$.
    Тогда множество
    $$
        F = \left\{n \in \N ~|~U_{n} \in \FF\right\}
    $$
    неразрешимо.
    Множество $F$ называется {\it индексным множеством}.
\end{theorem}

\begin{proof}[Доказательство (Есенин-Вольпин)]
    Сведем доказательство исходного утверждения к теореме Клини.
    Зафиксируем вычислимую функцию $f \in \FF$, и вычислимую функцию $g \notin \FF$.
    В силу универсальности $U$ существуют индексы $n, m \in \N$ такие, что $f = U_{n}$ и $g = U_{m}$.
    Рассмотрим тотальную функцию $h: \N \to \N$ такую, что
    $$
        \forall k \in \N \qquad h(k) = \begin{cases}
            m, & k \in F, \\
            n, & k \notin F.
        \end{cases}
    $$
    Если $F$ --- разрешимое множество, то $h$ вычислима, потому что $h(k) = m \cdot \chi_{F}\left(k\right) + n \cdot \left(1 - \chi_{F}\left(k\right)\right)$.
    Итак, $h$ вычислима и тотальна, тогда, по теореме Клини, $\exists n$ такое, что
    $$
        U_{n} = U_{h(n)}.
    $$
    Рассмотрим теперь, куда попадает число $n$.
    Оно либо попадает в $F$, либо нет.
    Предположим, что $k \in F$, тогда $U_{k} \in \FF$ с одной стороны.
    С другой стороны, поскольку $k \in F$, то $U_{h(k)} \in \FF \implies h(k) = m \implies U_{m} \in \FF \implies g \in \FF \implies$ противоречие.
    Совершенно аналогично рассматривается случай, когда $k \notin F$.
    Тогда $U_{k} \notin \FF \implies U_{h(k)} \notin \FF \implies U_{n} \notin \FF \implies f \notin \FF \implies$ противоречие.

    Итак, если бы множество $F$ было бы разрешимым, мы бы с вами изготовили такую функцию, которая использует свойство принадлежности множеству $F$ и делает все наоборот: если принадлежит, то выдает номер функции, которая не принадлежит, а если не принадлежит, то выдает номер функции, которая принадлежит этому множеству.
    А дальше мы пользуемся теоремой Клини: должна быть программа, чей смысл не меняется, однако в таком случае получается, что смысл любой программы меняется, отсюда и противоречие.
\end{proof}

Дадим также альтернативное доказательство этой теоремы, которое изначально предложил Райс.

\begin{proof}[Доказательство (Райс)]
    Зафиксируем функцию $\zeta$, которая нигде не определена.
    Попадает ли эта функция $\FF$ или нет?
    Рассмотрим два случая:
    \begin{description}
        \item[$\zeta \in \FF \implies$] проведем тоже рассуждение для $\overline{\FF}$, этого достаточно, поскольку разрешимость любого множества эквивалентно разрешимости его дополнения.
        \item[$\zeta \notin \FF \implies$] мы знаем, что $\FF \neq \varnothing$, значит существует вычислимая $f \in \FF$.
        Зафиксируем также $K$ --- какое-то перечислимое неразрешимое множество.
        Рассмотрим функцию $V: \N^{2} \pto \N$, которая устроена следующим образом:
        $$
            \forall n, x \in \N \quad V\left(n, x\right) \simeq \begin{cases}
                f(x), & n \in K, \\
                \zeta(x), & n \notin K.
            \end{cases}
        $$
        Покажем, что функция $V$ вычислима.
        На входе $(n, x)$ запускаем перечислитель множества $K$, если $n \notin K$, то алгоритм зациклится, что равносильно вычислению $\zeta$.
        Иначе, передаем управление вычислителю функции $f$.
        Ну или, если расписать формальнее, то $V\left(n, x\right) \simeq f\left(x\right) \cdot \omega_{K}(n)$, где $\omega_{K}$ вычислима как полухарактеристическая функция перечислимого множества.
        $U$ --- главная $\implies$ существует вычислимая тотальная $S$ такая, что
        $$
            \forall n \in \N \quad U_{S(n)} = V_{n}.
        $$
        Для любого $n \in \N$ рассмотрим два случая:
        \begin{description}
            \item[$n \in K \implies$] $V_{n} = f \in \FF \implies U_{S(n)} \in \FF \implies S(n) \in F$.
            \item[$n \notin K \implies$] $V_{n} = \zeta \notin \FF \implies U_{S(n)} \notin \FF \implies S(n) \notin F$.
        \end{description}
        Получается, что $\forall n$ $n \in K \iff S(n) \in F$ --- картина $m$-сводимости.
        Тогда неразрешимое множество $K \mreduce F$, но тогда $F$ неразрешимо, что и требовалось доказать.
        Заметим, что, по свойству $m$-сводимости, $\overline{K} \mreduce \overline{F}$, то есть $\overline{F}$ не перечислимо, поскольку $\overline{K}$ не перечислимо.
    \end{description}
\end{proof}
